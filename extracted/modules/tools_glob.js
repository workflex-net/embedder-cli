// Category: tools/glob
// Modules: 1
// Total size: 3,714 chars


// === Module: mZB (offset: 0xca7c78, 3,714 chars) ===
var mZB=z(()=>{rC();ZE();tKA();qI();wC();$ZB=dE({metadata:{name:"glob",displayName:"Find Files",description:"Finds files matching glob patterns (e.g., `src/**/*.ts`, `**/*.md`). Returns absolute paths sorted by modification time (newest first). Ideal for locating files by name or path structure.",category:"search"},inputSchema:S.object({pattern:S.string().min(1).describe("The glob pattern to match files against."),path:S.string().optional().describe("The directory to search in. Defaults to current working directory. Omit for default behavior.")}),validateParams:({pattern:A})=>{if(!A||A.trim()==="")return"Pattern cannot be empty.";return null},getDescription:({pattern:A,path:B})=>{if(B)return`Finding '${A}' in ${Mo.basename(B)}`;return`Finding '${A}'`},getLocations:()=>[],execute:async({pattern:A,path:B},Q)=>{let E=Date.now(),g=B?Mo.isAbsolute(B)?B:Mo.resolve(Q.workingDirectory,B):Q.workingDirectory;fA.debug("[glob] Starting search",{pattern:A,searchDir:g});try{try{if(!(await pME(g)).isDirectory())return{success:!1,llmContent:`Path is not a directory: ${g}`,returnDisplay:"Not a directory"}}catch{return fA.debug("[glob] Directory not found",{searchDir:g}),{success:!1,llmContent:`Directory not found: ${g}`,returnDisplay:"Directory not found"}}let C=[],I=!1;for await(let D of lZB({cwd:g,glob:[A]})){if(C.length>=rME){I=!0;break}let H=Mo.resolve(g,D),L=await Bun.file(H).stat().then((R)=>R.mtime.getTime()).catch(()=>0);C.push({path:H,mtime:L})}if(C.length===0)return fA.debug("[glob] No files found",{pattern:A,searchDir:g,duration:Date.now()-E}),{success:!0,summary:"No files found",llmContent:`No files found matching "${A}" in ${g}`,returnDisplay:"No files found",metadata:{matchCount:0}};C.sort((D,H)=>H.mtime-D.mtime);let w=C.map((D)=>D.path).join(`
`);return fA.info("[glob] Search completed",{pattern:A,matchCount:C.length,truncated:I,duration:Date.now()-E}),{success:!0,summary:`Found ${C.length} file${C.length===1?"":"s"}`,llmContent:`Found ${C.length} file${C.length===1?"":"s"} matching "${A}"${I?" (truncated)":""}:
${w}`,returnDisplay:`${C.length} file${C.length===1?"":"s"}${I?" (truncated)":""}`,metadata:{matchCount:C.length,truncated:I,pattern:A,searchDirectory:g}}}catch(C){let I=uQ(C);return fA.error("[glob] Search failed",{pattern:A,searchDir:g,error:I,duration:Date.now()-E}),{success:!1,llmContent:`Glob error: ${I}`,returnDisplay:`Error: ${I}`}}}})});import{stat as eME}from"fs/promises";import*as WN from"path";async function AHE(A,B,Q,E=!0){let g=await _KA(),C=["-nH","--hidden","--follow","--no-messages","--field-match-separator=|","--glob=!.git/*","--glob=!node_modules/*"];if(!E)C.push("-i");if(Q)C.push("--glob",Q);C.push("--regexp",B,A);let I=Bun.spawn([g,...C],{stdout:"pipe",stderr:"pipe"}),w=await new Response(I.stdout).text(),D=await I.exited,H=D===2;if(D===1||D===2&&!w.trim())return{matches:[],hasErrors:H};let L=w.trim().split(/\r?\n/),R=[];for(let U of L){if(!U)continue;let[G,Y,...J]=U.split("|");if(!G||!Y||J.length===0)continue;let c=Number.parseInt(Y,10);if(Number.isNaN(c))continue;let h=J.join("|"),T=await Bun.file(G).stat().catch(()=>null);if(!T)continue;R.push({path:G,lineNum:c,lineText:h,modTime:T.mtime.getTime()})}return R.sort((U,G)=>G.modTime-U.modTime),{matches:R,hasErrors:H}}function BHE(A,B,Q){let E=[`Found ${A.length} matches`],g="";for(let C of A){if(g!==C.path){if(g!=="")E.push("");g=C.path,E.push(`${C.path}:`)}let I=C.lineText.length>nZB?`${C.lineText.substring(0,nZB)}...`:C.lineText;E.push(`  Line ${C.lineNum}: ${I}`)}if(B)E.push(""),E.push("(Results truncated. Consider using a more specific path or pattern.)");if(Q)E.push(""),E.push("(Some paths were inaccessible and skipped)");return E.join(`
`)}var nZB=2000,pZB=100,rZB;
