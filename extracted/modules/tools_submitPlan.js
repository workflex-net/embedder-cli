// Category: tools/submitPlan
// Modules: 1
// Total size: 5,924 chars


// === Module: tZB (offset: 0xca63c5, 5,924 chars) ===
var tZB=z(()=>{rC();fw();ZN();qI();bKA();wC();_ZB=dE({metadata:{name:"submitPlan",displayName:"Submit Plan",description:`Submit your plan for user approval after you have finished writing it.

Call this tool when:
- You have completed writing a comprehensive plan
- The plan is ready for implementation
- You want to ask the user if they approve the plan

The user will be presented with options to:
- Approve and Execute: Switch to act mode and begin implementing the plan
- Tell embedder to do something different: Text input to redirect with new instructions

Do NOT call this tool:
- Before you have finished writing the plan
- If you still have unanswered questions about the implementation
- If the user has indicated they want to continue planning`,category:"system"},inputSchema:S.object({}),validateParams:()=>{return null},getDescription:()=>"Submitting plan for approval",getLocations:()=>[],execute:async(A,B)=>{try{if(!B.sessionSlug||!B.sessionCreatedAt)return{success:!1,llmContent:"Session information not available. Cannot determine plan file path.",summary:"Cannot submit plan"};let Q=aU(B.projectRoot,B.sessionSlug,B.sessionCreatedAt),E=Bun.file(Q);if(!await E.exists())return{success:!1,llmContent:`Plan file not found at ${Q}. You must write your plan to the file before calling submitPlan.`,returnDisplay:"Plan file not found",summary:"Plan file not found"};let g=await E.text();if(g.length<50)return{success:!1,llmContent:"Plan file is too short (less than 50 characters). Please write a more comprehensive plan before submitting.",returnDisplay:"Plan too short",summary:"Plan validation failed"};let C=yB.getState().questionHandler;if(!C)return{success:!1,llmContent:"Question handler not available. UI integration required.",summary:"Cannot submit plan for approval"};let I=yB.getState().modeHandler;if(!I)return{success:!1,llmContent:"Mode handler not available. UI integration required.",summary:"Cannot change modes"};let w={id:`plan_${Date.now()}_${Math.random().toString(36).slice(2,9)}`,questions:[{question:"Do you approve this plan and want to start executing it?",header:"Plan Review",options:[{label:"Approve and Execute",description:"Switch to act mode and begin implementing the plan"}],multiSelect:!1}],timestamp:Date.now(),markdownContent:g,enterToSelectAndSubmit:!0,customInputLabel:"Tell embedder to do something different",customInputPlaceholder:"Type new instructions..."},H=(await C(w)).answers["Plan Review"];if(!H)return{success:!1,llmContent:"No response received from user.",summary:"Plan approval cancelled"};if(H.isCustom&&H.answers[0]){let R=yB.getState().redirectPromptHandler;if(R){let U=H.answers[0];setTimeout(()=>{R(U)},dZB)}return{success:!0,summary:"User redirecting with new instructions",llmContent:"The user has provided new instructions. Stopping current operation.",metadata:{redirected:!0,newMode:"plan"}}}if(H.answers[0]==="Approve and Execute"){I("act");let R=yB.getState().messageInjectionHandler;if(R)R(bZB);let U=yB.getState().planExecutionHandler;if(U)setTimeout(()=>{U(g)},dZB);return{success:!0,summary:"Plan approved - switching to act mode",llmContent:`Plan approved. Plan file is at: ${Q}. Switching to act mode for execution.`,metadata:{approved:!0,newMode:"act",planPath:Q}}}return{success:!1,llmContent:"Unexpected response from user.",summary:"Plan approval failed"}}catch(Q){return{success:!1,llmContent:`Error submitting plan for approval: ${uQ(Q)}`,summary:"Failed to submit plan"}}}})});import{chmod as tME,mkdir as uZB,rm as uME}from"fs/promises";import{homedir as aME,tmpdir as lME}from"os";import{join as lJ}from"path";var{$:aZB}=globalThis.Bun;async function mME(A){try{return await Bun.file(A).stat(),!0}catch{return!1}}async function nME(A){let E=lJ(A,"rg"),g="x64-linux",C=$ME["x64-linux"];if(!C)throw Error(`Unsupported platform: x64-linux
Please install ripgrep manually:
  macOS: brew install ripgrep
  Linux: apt install ripgrep
  Windows: choco install ripgrep`);let I=`ripgrep-${dKA}-${C.target}.${C.ext}`,w=`https://github.com/BurntSushi/ripgrep/releases/download/${dKA}/${I}`;await uZB(A,{recursive:!0});let D=lJ(lME(),`ripgrep-install-${Date.now()}`);await uZB(D,{recursive:!0});let H=lJ(D,I);try{let L=await fetch(w);if(!L.ok)throw Error(`Failed to download ripgrep: ${L.status} ${L.statusText}`);let R=await L.arrayBuffer();if(await Bun.write(H,R),C.ext==="tar.gz"){let U=["tar","-xzf",H,"--strip-components=1","-C",D];U.push("--wildcards","*/rg");let G=await aZB`${U}`.quiet().nothrow();if(G.exitCode!==0)throw Error(`Failed to extract ripgrep archive: ${G.stderr.toString()}`);let Y=lJ(D,"rg");await Bun.write(E,await Bun.file(Y).arrayBuffer())}else if(C.ext==="zip"){let U=`$ProgressPreference = 'SilentlyContinue'; Expand-Archive -Path '${H}' -DestinationPath '${D}' -Force`,G=await aZB`powershell -NoProfile -Command ${U}`.quiet().nothrow();if(G.exitCode!==0)throw Error(`Failed to extract ripgrep archive: ${G.stderr.toString()}`);let Y=lJ(D,`ripgrep-${dKA}-${C.target}`),J=lJ(Y,"rg.exe");await Bun.write(E,await Bun.file(J).arrayBuffer())}return await tME(E,493),E}finally{await uME(D,{recursive:!0,force:!0}).catch(()=>{})}}async function _KA(){if(lx)return lx;let A=!1,B=A?"rg.exe":"rg",Q=A?lJ(process.env.LOCALAPPDATA||"","embedder"):lJ(aME(),".embedder","bin"),E=lJ(Q,B);if(await mME(E))return lx=E,lx;let g=Bun.which("rg");if(g)return lx=g,lx;return lx=await nME(Q),lx}async function*lZB(A){let B=await _KA(),Q=["--files","--glob=!.git/*"];if(A.follow!==!1)Q.push("--follow");if(A.hidden!==!1)Q.push("--hidden");if(A.glob)for(let w of A.glob)Q.push(`--glob=${w}`);let E=Bun.spawn([B,...Q],{cwd:A.cwd,stdout:"pipe",stderr:"ignore"}),g=E.stdout.getReader(),C=new TextDecoder,I="";try{while(!0){let{done:w,value:D}=await g.read();if(w)break;I+=C.decode(D,{stream:!0});let H=I.split(/\r?\n/);I=H.pop()||"";for(let L of H)if(L)yield L}if(I)yield I}finally{g.releaseLock(),await E.exited}}var dKA="14.1.1",$ME,lx=null;
